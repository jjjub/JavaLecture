### 자바, java

- 객체 지향 프로그래밍 언어

- Object Oriented Programming Language > OOP

- 객체를 중심으로 프로그램을 만드는 방식

- 클래스라는 설계도를 사용해서, 
  
  객체라는 것을 만들고,
  
  만들어지는 객체를 사용해서 내가 원하는 행동을 구현하는 것.

### 클래스, Class

1. 클래스, Class
   
   - 객체를 만드는 설계도
   
   - 객체를 분류하는 기준
   
   - 붕어빵 틀 > 붕어빵, 잉어빵 틀 > 잉어빵
   
   - 객체를 정의하는 틀(설계도)이다.
   
   - 클래스내에서 멤버 변수와 멤버 메서드를 선언한다. > 객체가 가지는 데이터와 행동이 된다.

2. 객체(개체), Object
   
   - 붕어빵
   
   - 객채 = 데이터 (변수)+ 행동(메서드)

3. 인스턴스, Instance
   
   - 붕어빵
   
   - 메모리에 실체화된 객체

4. 추상화
   
   - 실존하는 객체들의 공통점을 모아서 정의
   
   - 단순화

5. 정보은닉
   
   - 객체의 내부를 외부에 노출시키지 않는 작업
   
   - 내부를 외부로부터 보호하는 역할
   
   - 외부에서 객체를 봤을 때 행동을 단순화시키는 역할

6. 캡슐화
   
   - 외부로부터 내부를 보호하는 작업

7. 인터페이스
   
   - 케이스의 구멍 + 버튼 

8. 프로퍼티(Property), 속성(Attribute)
   
   - 데이터(변수
   
   - 객체가 가지는 정보

9. 행동(Behavior)
   
   - 메서드
   
   - 객체가 가지는 행동

10. 상속(Inheritance)
    
    - 클래스간의 상속

### 클래스 선언하기

1. 클래스 선언하기

2. 멤버 선언하기
   
   a. 변수
   
   b. 메서드

### 클래스 선언할 때 권장사항

- 클래스 1개당 물리적인 파일을 1개를 만든다.
  
  - 클래스 파일 하나에 여러개 클래스 지양

- 관리가 용이하기 때문

### 클래스 선언할 때 절대사항

- 파일의 이름과 클래스의 이름이 동일해야 한다.

- 컴파일 에러

- 하나의 파일안에 2개 이상의 클래스를 선언

- 파일내의 모든 클래스 중 public를 가지는 클래스는 유일해야 한다,

- public  클래스 > 대표 클래스 > 대표 클래스의 이름이 파일명이 된다.

```java
//클래스 선언(정)
class Member{

    //멤버 변수
    public String name;
    public int age;

    //멤버 메서드
public void hello() {    //static 제외
        System.out.printf("안녕하세요. 저는 %s입니다.\n", name);
    }
```

OOO 지정자(제어자)

- 클래스 or 클래스 멤버 > 부가적이 기능을 제공하는 키워드

### 접근 지정자(제어자),  Access Modifier

- 클래스 멤버에 붙여서 사용한다.

- 클래스 자체에 붙여서 사용한다.

- 지역 변수에는 사용이 불가능하다.
1. public
   
   - 외부로부터 접근 허용(100%)

2. private
   
   - 외부로부터 접근 불허용(100%)

----------------------

1. protected
   
   - public과 private의 중간전동

2. (default)
   
   - public과 private의 중간정도

접근 지정자 가이드

1. 멤버 변수는  무조건 private
   
   1. 멤버 변수를 접근 가능한 입출력 메서드를 생성한다.

2. 멤버 메서드는 경우에 따라 private or public을 사용

public 변수 > Field(필드)

Getter+Setter > Property

필요에 따라 Getter 혹은 Setter중 하나만 만들 수 있음

### 클래스의 사용목적

- 데이터의 집합
  
  - Point 클래스 = x와 y의 집합
  
  - Size 클래스 = width와 height와 name의 집합

- 데이터 집합 + 메서드 추가 >자료형 역할 + 자료들을 사용하는 행동
  
  - Member 클래스 = name와 age의 집합 +hello()메서드

### 

### 생성자, Construtor

- (특수한 목적을 가지는) 메서드

- 객체의 멤버(변수)를 초기화하는 역할(***)

- 접근지정자 public

- 반환값 존재하지 않음 > void도 생략

- 메서드명 == 클래스명객체를 생성직후 초기화 역할

- 반드시 new와 함께 호출이 가능하다. 

- 생성자는 태어날때 한번 호출되고 그다음부터 호출 불가능

- 오버로딩 > 기본생성자 없어짐(기본생성자일을 오버로딩한 생성자가 처리가능하기 때문)

- 단독호출  불가능

- (클래스를 사용해서) 객체를 생성할때 자동으로 호출되는 메서드. 객체의 멤버를 초기화하는 역할

```java
//기본생성
public Box() {
    this.size = null;
    this.price = 0; //>b1을 초기화하지 않아도 b1.getPrice = 0
}
```

### 생성자의 종류

- 객체 생성자
  
  - 객체 멤버를 초기화(static이 안붙은 멤버)

- 정적 생성자
  
  - 정적 멤버를 초기화(static이 붙은 멤버)

### 생성자 오버로딩

- 생성자도 메서드의 일종이라서, 인자리스트를 활용한 오버로딩이 가능하다.

### static(정적) 키워드

- 지시자(제어자) 중 하나

- 클래스로부터 생성된 모든 객체들이 공유하는 멤버

- 모든 객체들이 공유해야 하는 데이터(변수) ir 행동(메서드)가 필요할때

- 클래스 or 클래스 멤버에 붙이는 키워드

- 지역변수에 사용 불가
1. 멤버 변수

2. 멤버 메서드

this 객체접근지정자(나)

객체내에서 객체 자신을 부를때만 가능

공용변수 접근, 정적멤버 = .클래스명

공유할거있으면 static 각각 따로 할당 객체멤버

- 객체 
  
  - 변수 > 객체 변수, 개인 데이타
  
  - 메서드 > 객체 메서드, 개인행동

- 정적
  
  - 변수 > 정적변수, 공용 변수, 집합 데이터
  
  - 메서드 > 정적 메서드, 공용 메서드, 집합행동

### 상속, Inheritance

- 클래스와 클래스간의 관계. 부모클래스의 객체 멤버를 자식클래스에게 물려주는 기술

- 부모가 가지는 재산을 자식에게 물려주는 행동

- 코드 재사용으로인한 비용절감

- 부모 클래스에서 이미 선언된 코드를 자식 클래스에서 재구현없이 코드를 재사용하기 위한 기술 > 비용 절감(코드 재사용)

상속 관계에 있는 클래스 호칭

- 부모 클래스 <-> 자식 클래스

- 슈퍼 클래스 <-> 서브 클래스

- 기본 클래스 <-> 확장 클래스

- 기본 클래스 <-> 파생 클래스

자바에서 다중 상속 불가능

### Object 클래스

- 모든 클래스의 루트 클래스

- Object의 멤버는 모든 클래스에게 상속

- 따로 명시하지 않으면 컴파일러가 자동으로     extends Object

- 개발자가 선언한 모든 클래스는 자동으로 Object 클래스를 상속받는다.

- 모든 클래스의 근원 클래스 >

- 루트 클래스(Root Class)

- Object 클래스는 멤버를 9개 구현 > 상속에 의해서 모든 클래스에게 물려진다. > 모든 클래스는 9개의 메서드를 가지고 있다. > 공통기능

### 메서드 오버라이딩, Method Overriding

- 메서드 재정의

- 변수도 오버라이딩이 물리적으로는 있지만 안씀(의미없음)

```java
class OverridingParent{

public String name;
public void hello() {
    System.out.printf("안녕하세요. 좋은 아침입니다. 저는 %s입니다.\n", this.name);
    }

}

class OverridingChild extends OverridingParent{
public void hello() {
    System.out.printf("하이~ 방가~ 난 %s야\n", this.name);
    }

}
```

### final 키워드

- 한번 결정하면 바꿀 수 없다.

- 안정성이 높아진다. > 유연성이 떨어진다.
1. 변수 적용(지역 변수, 멤버 변수)
-  초기화 이후에 값을 변경할 수 없다.

- 상수
2. 메서드 적용
- 상속 시 오버라이딩 방지
3. 클래스 적용
- 상속을 방지

### 메서드 재정의

- 상속시 발생하는 상황

- 부모가 물려준 메서드를 그래도 사용하지 않고, 자신이 직접 선언 후 부모 메서드를 대신해서 자신의 메서드를 사용하는 기술

- 사용자 경험을 살리기 위해서 사용 

# 
